% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse.R
\name{pm_parse}
\alias{pm_parse}
\title{Parse Street Addresses}
\usage{
pm_parse(.data, input, address, output, new_address, ordinal = TRUE,
    include_commas = FALSE, include_unit = TRUE, keep_parsed = "no",
    keep_ids = FALSE, houseSuf_dict, dir_dict, street_dict, suffix_dict, unit_dict,
    city_dict, state_dict, locale = "us")
}
\arguments{
\item{.data}{A source data set to be parsed}

\item{input}{Describes the format of the source address. One of either \code{"full"} or \code{"short"}.
A short address contains, at the most, a house number, street directionals, a street name,
a street suffix, and a unit type and number. A full address contains all of the selements of a
short address as well as a, at the most, a city, state, and postal code.}

\item{address}{A character variable containing address data to be parsed}

\item{output}{Describes the format of the output address. One of either \code{"full"} or \code{"short"}.
A short address contains, at the most, a house number, street directionals, a street name,
a street suffix, and a unit type and number. A full address contains all of the selements of a
short address as well as a, at the most, a city, state, and postal code.}

\item{new_address}{Name of new variable to store rebuilt address in.}

\item{ordinal}{A logical scalar; if \code{TRUE}, street names that contain numeric words values
(i.e. "Second") will be converted and standardized to ordinal values (i.e. "2nd"). The
default is \code{TRUE} because it returns much more compact clean addresses (i.e.
"168th St" as opposed to "One Hundred Sixty Eigth St").}

\item{include_commas}{A logical scalar; if \code{TRUE}, a comma is added both before and after the city
name in rebuild addresses. If \code{FALSE} (default), no punctuation is added.}

\item{include_unit}{A logical scalar; if \code{TRUE} (default), the unit name and number (if given)
will be included in the output string. Otherwise if \code{FALSE}, the unit name and number
will not be included.}

\item{keep_parsed}{Character string; if \code{"yes"}, all parsed elements will be
added to the source data after replacement. If \code{"limited"}, only the \code{pm.city},
\code{pm.state}, and postal code variables will be retained. Otherwise, if \code{"no"},
only the rebuilt address will be added to the source data (default).}

\item{keep_ids}{Logical scalar; if \code{TRUE}, the identification numbers
will be kept in the source data after replacement. Otherwise, if \code{FALSE},
they will be removed (default).}

\item{houseSuf_dict}{Optional; name of house suffix dictionary object.  Standardizationl
and parsing are skipped if none is specified.}

\item{dir_dict}{Optional; name of directional dictionary object. If none is specified,
the full default directional dictionary will be used.}

\item{street_dict}{Optional; name of street dictionary object. Standardizationl is skipped
if none is specified.}

\item{suffix_dict}{Optional; name of street suffix dictionary object. If none is specified,
the full default street suffix dictionary will be used.}

\item{unit_dict}{Optional; name of unit dictionary object - NOT CURRENTLY ENABLED}

\item{city_dict}{Required for \code{"full"} addresses; name of city dictionary object.}

\item{state_dict}{Optional; name of state dictionary object. If none is specified,
the full default state dictionary will be used.}

\item{locale}{A string indicating the country these data represent; the only
current option is "us" but this is included to facilitate future expansion.}
}
\value{
An updated version of the source data with, at a minimum, a new variable containing
    standardized street addresses for each observation. Options allow for columns containing
    parsed elements to be returned as well.
}
\description{
A wrapper around the parse functions that can be used to shorten all
    of \code{postmastr}'s core code down to a single function call once dictionaries
    have been created and tested against the data.
}
\examples{
# construct dictionaries
dirs <- pm_dictionary(type = "directional", filter = c("N", "S", "E", "W"), locale = "us")
sufs <- pm_dictionary(type = "suffix", locale = "us")
mo <- pm_dictionary(type = "state", filter = "MO", case = c("title", "upper"), locale = "us")
cities <- pm_append(type = "city",
    input = c("Brentwood", "Clayton", "CLAYTON", "Maplewood", "St. Louis",
              "SAINT LOUIS", "Webster Groves"),
    output = c(NA, NA, "Clayton", NA, NA, "St. Louis", NA))

# add example data
df <- sushi1

# temporary code to subset unit
df <- dplyr::filter(df, name != "Drunken Fish - Ballpark Village")

# parse, full output
pm_parse(df, input = "full", address = address, output = "full",
    dir_dict = dirs, suffix_dict = sufs, city_dict = cities, state_dict = mo)

# parse, short output
pm_parse(df, input = "full", address = address, output = "short",
    new_address = clean_address, dir_dict = dirs, suffix_dict = sufs,
    city_dict = cities, state_dict = mo)

}
